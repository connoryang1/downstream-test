const math = @import_module("<math>");

const aux = @import_module("<downstream/_auxlib>");

fn has_ingest_capacity(S: u32, T: u32) bool {
    const _ = T;
    return (aux.popcount(S) == 1) and S > 1;
}

fn assign_storage_site(S: u32, T: u32) u32 {
    const s = aux.bit_length(S) - 1;
    const blT = aux.bit_length(T);
    const t = aux.floor_subtract(blT, s); // Current epoch
    const h = aux.ctz(T + 1); // Current hanoi value
    const i = aux.overflow_shr(T, h + 1);
    // ^^^ Hanoi value incidence (i.e., num seen)

    // Num full-bunch segments
    const j = aux.bit_floor(i) - 1;
    const B = aux.bit_length(j); // Num full bunches
    // Bunch position
    const _1: u32 = 1;
    var k_b = aux.overflow_shl(_1, B) * (s + 1 - B);
    // substituting t = s - blT into h + 1 - t
    var w = h + s + 1 - blT; // Segment width
    var o = w * (i - (j + 1)); // Within-bunch offset

    const is_zeroth_bunch = i == 0;
    k_b = if (!is_zeroth_bunch) k_b else 0;
    o = if (!is_zeroth_bunch) o else 0;
    w = if (!is_zeroth_bunch) w else s + 1;

    // handle discard without storing for non-top n(T) hanoi value...
    return if (h >= t) k_b + o + (h % w) else S;
    // within-segment offset: p  ^^^^^^^
}
