const math = @import_module("<math>");

const aux = @import_module("<downstream/_auxlib>");

fn has_ingest_capacity(S: u32, T: u32) bool {
    const _ = T;
    return (aux.popcount(S) == 1) and S > 1;
}

fn assign_storage_site(S: u32, T: u32) u32 {
    const s = aux.bit_length(S) - 1;
    const blt = aux.bit_length(T);
    const t = aux.floor_subtract(blt, s); // Current epoch
    const h = aux.ctz(T + 1); // Current hanoi value

    // Hanoi value incidence (i.e., num seen)
    const i = T >> (h + 1);

    // Num full-bunch segments
    const j = aux.bit_floor(i) - 1;
    const B = aux.bit_length(j); // Num full bunches
    // Bunch position
    const one: u32 = 1;
    var k_b = (one << B) * (s + 1 - B);
    // substituting t = s - blt into h + 1 - t
    var w = h + s + 1 - blt; // Segment width
    var o = w * (i - (j + 1)); // Within-bunch offset

    const is_zeroth_bunch = i == 0;
    k_b = if (!is_zeroth_bunch) k_b else 0;
    o = if (!is_zeroth_bunch) o else 0;
    w = if (!is_zeroth_bunch) w else s + 1;

    // Within-segment offset, avoiding divide by zero
    const p = h % math.max(w, 1);

    // handle discard without storing for non-top n(T) hanoi value...
    return if (h >= t) k_b + o + p else S;
}
